! -I0 -i5 -a1 -b2 -d3 -f4 -m5 -Rr
      module m1
           integer k
           enum, bind(c)

                enumerator :: red =1, blue, black =5
                enumerator yellow
                enumerator gold, silver, bronze
                enumerator :: purple
                enumerator :: pink, lavender

           endenum
      contains
           function f(x)
                print *,'abc
     9      def'
                print *,"abcd
     8        efgh"
                return
           end function f
#ifdef usempi
           function f1(x,m)
                real x,m
#elif defined(useopenmp)
           function f1(x,m,n)
                real x,m,n
#else
           function f1(x)
                real x
#endif
                continue
           end function f1
      end module m1

      program progfixed
           type mytype  ! mytype
                integer i
                real x
           end type mytype
#ifdef abcde
           real klm@@@(10)
#endif
           real do(100)
           integer x(100)
           type(mytype)  xyz
           character*1000 astring
           continue
           a_ap: do i=1,20
              continue
           enddo a_ap
           end = 10
           if ( e .eq. n .and.
     *          e .eq. m    )then
               npar   = npar   + 1
           endif
           do i=1,
c a comment
c a comment
     x     1
c a comment
     x     0
              continue
           enddo
           do 123 i=1,2
              continue
  123      continue
           print *,'; function ',indx," function "
           continue
99880      FORMAT ('  function ')
99870      FORMAT(1X,'Invalid species name',2X,A8)
           do i=1,10
              do (i) = 5
              continue
              do(i) = 5
              continue
           enddo
           x = y   ! function values
           continue

           astring = " ! this
     x is
     x no comment!"
           print *,a,b,
     x             c,d
     x            ,e,f
           continue
           print *,a,b,
     x             c,d
     x            ,e,f
           loop: do i=1,20
              block
                do 90 k=1,90
                   do 90 k1=1,4
                      call one(a)
                      do 7 j=1,20
                         call two(a)
  7                   x=x+j
                      continue
  90            continue
                continue
              end block
           enddo loop

           bbb: block
             continue
           end block bbb

           sc: select case(ja)
             case(1)
                continue
             case(2)
                continue
           end select sc
           continue
           do i=1,20
              block
                continue
              end block
           enddo
           critical
                x=y
           endcritical
           critical
                x=y
           endcritical
           critical
                x=y
           end critical
           wv: if ( a.eq.b) then
               continue
           endif wv
           if (.false.) goto 88
           if (.false.) goto 99999
  88       if ('x' .eq. "abc''d") l=1
99999      continue
           if ('x' .eq. "abc''d") l=1
           continue
           if ('x' .eq. "abc''d")then
               continue
           endif
           ASSOCIATE ( Z => EXP(-(a**2+Y**2)) * COS(THETA))
            PRINT *, A+Z, A-Z
           END ASSOCIATE

           forall(i=1:4) x(i)=5
           continue
           forall(i=1:4)  ! forall
                x(i)=6
           end forall

           where(x.eq.0) x=5 ! where
           continue
           where(x.eq.0)
                x=10
           endwhere
           continue

           where(x.eq.0)
                x=10
           elsewhere
                x=11
           endwhere

           select case(ia)
             case(1)
                print *,3
                do i=1,9
                   continue
                enddo
             case(2)
                print*,6
             case default
                print *,0
           endselect

      end program

      subroutine one(a)
           continue
        entry myentry
           continue
           return
      end subroutine
      subroutine two(a)
           continue
d              print *,'debug i=',i
D              print *,'debug j=',j
           x = 4 +
c next line starts with <tab>
     1     5 +
c next line starts with <sp><tab>
     2     5+
c next line starts with <sp><sp><tab>
     3     5+
c next line starts with <sp><sp><sp><tab>
     4     5+
c next line starts with <sp><sp><sp><sp><tab>
     5     5+
c next line starts with <sp><sp><sp><sp><sp><tab>
     6     5
           return
      endsubroutine
      subroutine three(a)
           continue
           return
      end subroutine three
      subroutine four(a)
           continue
           return
      endsubroutine four
      subrou
     xtine five
           continue
           return
      end subroutine five
      subroutine seven
           a = 1
     x     + 2   ! comment 1
     y     + 3   ! comment 2
     y     + 4
     y     + 5
     y     + 6
           a = 1
     x     + 2   ! comment 1
     y     + 3   ! comment 2
#ifdef klm
     y     + 4 syntax error
     y     + 5 syntax error
#endif
     y     + 6
      end subroutine seven
      subroutine multiline_preproc
#ifdef one\
two\
three
           do i=1,10
#elif \
defined(q)
           do i=1,5
#else
           do i=1,7
#endif
              x=x+4
           enddo
      end subroutine multiline_preproc

      subroutine nok
           implicit none
           type domain_data
                real, dimension(:, :), allocatable :: temperature
                integer:: ibound, icopy, todomain
           end type

           type(domain_data), dimension(2), target :: dom
           allocate(dom(1) % temperature(20, 20))
           dom(1) % temperature = 0.
           dom(1) % temperature(:, 1) = 1.
      end subroutine nok


      ! testing with indentfix:
      subroutine testfix
           implicit none
           integer i,j,k
           do i=1,10
c             comment
              continue
              do j=1,6
                 continue
                 !  findentfix: do
                    do k=1,7
                       continue
                    enddo
C FINDENTFIX: enddo
              enddo
              continue
           enddo
      end subroutine testfix
